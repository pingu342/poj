// マーシャとビルはおはじきを集めている
// 2人は彼らのコレクションを均等に分け合いたいと考えている
// もしすべてのおはじきの価値が同じなら、ちょうど半分こすれば良いから簡単である
// しかし、他より大きかったり綺麗なおはじきがある
// そこで彼らはまず、おはじきに1から6の値で価値付けをした
// そして価値が均等になるように分け合おうとしたが、それが不可能な場合があることがわかった
// 例えば、価値1のおはじきが1つ、価値3が1つ、価値4が2つある場合は、価値が均等になるように分け合うことができない
// そこで、おはじきを均等に分け合うことができるかどうか確認するプログラムを作成せよ
//
// 入力
// 
// 価値1のおはじきが1つ、価値3が1つ、価値4が2つある場合の入力
// 1 0 1 2 0 0 
// 
// 出力
//
// Collection #1:
// Can't be divided.
//
#include <stdio.h>

int in[6];

//dp[ビー玉の価値-1][作る価値]:=価値-1のビー玉の余った個数
#define DP_SZ (20000*6/2+1)
int dp[DP_SZ];
/*
void print(int d, int n)
{
	int j;
	printf("%d: ",  n);
	for (j=0;j<=d;j++)
		printf("%+d ", dp[j]);
	printf("\n");
}
*/
int check(int d)
{
	int i, j;
	for (i=0;i<DP_SZ;i++) dp[i]=-1;
	dp[0]=0;

	// 動的計画法バージョン
	// 全探索より高速
	//  (参考)
	//   http://d.hatena.ne.jp/TobiasGSmollett/20130524/1369386185
	//   http://gushwell.ifdef.jp/etude/SubsetSum.html
	//   http://dai1741.github.io/maximum-algo-2012/docs/dynamic-programming/
	//
	// 入力例 1 1 1 2 0 0
	// 価値の合計が14
	// 価値の和7を作れるかどうかが問題
	// 
	// i=0: +1 +0 -1 -1 -1 -1 -1 -1 
	//  まず価値1のおはじきだけを使う
	//  価値の和0を作ることが可能 その結果、価値1のおはじきは1個余る dp[0]=1
	//  価値の和1を作ることが可能 その結果、価値1のおはじきは0個余る dp[1]=0
	//  価値の和2以上を作ることは不可能 dp[2]=-1
	//
	// i=1: +1 +1 +0 +0 -1 -1 -1 -1
	//  上記の結果に、価値2のおはじきを使うことを考える
	//  価値の和0は、価値1のおはじきだけで既に作れている(上記結果でdp[0]!=-1)ので、価値2のおはじきは1個余る dp[0]=1に更新
	//  価値の和1は、価値1のおはじきだけで既に作れている(上記結果でdp[1]!=-1)ので、価値2のおはじきは1個余る dp[1]=1に更新
	//  価値の和2は、価値1のおはじきだけでは作れなかった(上記結果でdp[2]==-1)が、価値2のおはじきで作ることが可能(なぜならdp[価値の和-おはじきの価値]=dp[2-2]=dp[0]==1なので価値2のおはじきは1つ余っているから) その結果、価値2のおはじきは0個余る dp[2]=0に更新
	//  価値の和3は、価値1のおはじきだけでは作れなかった(上記結果でdp[3]==-1)が、価値1と価値2のおはじきで作ることが可能 その結果、価値2のおはじきは0個余る dp[3]=0に更新
	//  価値の和4以上を作ることは不可能 dp[4]=-1に更新
	//
	// i=2: +1 +1 +1 +1 +0 +0 +0 -1 
	//  上記の結果に、価値3のおはじきを使うことを考える
	//  価値の和0,1,2,3は既に作れている(上記結果でdp[0~3]!=-1)なので、価値3のおはじきは1個余る dp[0~3]=1に更新
	//  価値の和4は未だ作れていない(上記結果でdp[4]==-1)が、価値3のおはじきで作ることが可能(dp[4-3]=dp[1]==1なので価値3のおはじきは1つ余っているから) その結果、価値3のおはじきは0個余る dp[4]=0に更新
	//
	//  以降同じ処理を繰り返す...
	//
	for (i=0;i<6;i++) {
		for (j=0;j<=d;j++) {
			if (dp[j]>=0) dp[j]=in[i]; //価値jを作ったときに価値iのおはじきがdp[j]個余る
			else if(j<i+1 || dp[j-i-1]<=0) dp[j]=-1; //価値jを作ることはできない
			else dp[j]=dp[j-i-1]-1;
			//print(d, i);
		}
	}
	return (dp[d] >= 0);
}

int main()
{
	int n, i, s, r;
	for (n=1;scanf("%d %d %d %d %d %d", &in[0], &in[1], &in[2], &in[3], &in[4], &in[5]);n++) {
		for (i=0,s=0;i<6;i++) {
			s+=in[i]*(i+1);
		}
		if (s==0) break;
		if (s%2) r=0;  //奇数は均等にわけられない
		else r=check(s/2);
		printf("Collection #%d:\nCan%s be divided.\n\n", n, r?"":"'t");
	}
}
