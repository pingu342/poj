// 円状にn人が立っている
// n人にはそれぞれ1,2,...,nの番号が振られている
// そのm番目の人が処刑され、残りm番目の人が処刑され、、、残り1人になるまで処刑が続く
// 例えばn=6、m=5ならば、5,4,6,2,3の番号順に処刑され、最後に残った1が助かる
// ここで、悪者がk人、善者がk人いるとする (0 < k < 14)
// 善者には1,2,...,kの番号が、悪者にはk+1,k+2,...,2kの番号が振られているとする
// 善者が処刑される前に、悪者が全員処刑されるような、最小のmを求めよ
//
// k=1,n=2: 1(good),2(bad)
// m=1: 1(good)
// m=2: 2(bad)
//
// k=2: 1(good),2(good),3(bad),4(bad)
// m=1: 1(good),2(good),3(bad) 
// m=2: 2(good),4(bad),3(bad)
// m=3: 3(bad),2(good),4(bad)
// m=4: 4(bad),1(good),3(bad)
// m=5: 1(good),3(bad),4(bad)
// m=6: 2(good),1(good),4(bad)
// m=7: 3(bad),4(bad),1(good)
//
// m=1: 1, 2, 3, 4
// m=2: 4, 1, 3, 2
// m=3: 4, 2, 1, 3
// m=4: 2, 4, 3, 1
// m=5: 1, 4, 2, 3
// m=6: 2, 1, 4, 3
// m=7: 3, 4, 1, 2
//
// k=3: 1(good),2(good),3(good),4(bad),5(bad),6(bad)
// m=4: 4(bad),2(good),1(good),3(good),6(bad)
// m=5: 5(bad),4(bad),6(bad),2(good)
//

#include <stdio.h>

typedef unsigned int C;

int main()
{
	int k, m, n, i, e, y[14]={0};
	C c;
	while (scanf("%d", &k) != EOF && k) {
		if (y[k])
			m = y[k];					//計算済みはキャッシュ
		else
			for (m=k+1;;m++) {
				c = ~(C)(-(1<<k));		//善者のみビットを立てる
				for (e=0,n=k*2;n>k;n--) {
					e = (e+m-1) % n;	//次に処刑される人のビット番号
					if (c & (C)1<<e)	//善者が処刑されるならループを抜ける
						break;
				}
				if (n==k)				//善者の処刑前に悪者がすべて処刑されていればOK (悪者がすべて処刑されたことで人数がk人になっていたらOK)
					break;
			}
		y[k] = m;
		printf("%d\n", m);
	}
}

/* [テストデータ]

INPUT
1
2
3
4
5
6
7
8
9
10
11
12
13
0

OUTPUT
2
7
5
30
169
441
1872
7632
1740
93313
459901
1358657
2504881

*/
